<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Company News Aggregator (Crafted by Somik)</title>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Babel -->
    <script crossorigin src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- SheetJS -->
    <script crossorigin src="https://cdn.sheetjs.com/xlsx-0.20.0/package/dist/xlsx.full.min.js"></script>

    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>

    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
        }
    </style>
</head>

<body>
    <div id="debug-error"
        style="background: #fee2e2; color: #991b1b; padding: 20px; display: none; margin: 20px; border: 1px solid #f87171; border-radius: 8px;">
        <h3 style="font-weight: bold; margin-bottom: 8px;">Startup Error</h3>
        <pre id="debug-content" style="white-space: pre-wrap; font-family: monospace;"></pre>
    </div>

    <div id="root"></div>

    <script>
        window.onerror = function (msg, url, line, col, error) {
            document.getElementById('debug-error').style.display = 'block';
            document.getElementById('debug-content').textContent += `Error: ${msg}\nAt: ${url}:${line}:${col}\n\n`;
            return false;
        };
    </script>

    <script type="text/babel">
        try {
            const { useState, useEffect } = React;

            // Checks
            if (typeof XLSX === 'undefined') throw new Error("SheetJS failed to load.");

            // --- UTILS ---

            // Stop words for contextual analysis
            const STOP_WORDS = new Set([
                'a', 'about', 'above', 'after', 'again', 'against', 'all', 'am', 'an', 'and', 'any', 'are', "aren't", 'as', 'at',
                'be', 'because', 'been', 'before', 'being', 'below', 'between', 'both', 'but', 'by', "can't", 'cannot', 'could',
                "couldn't", 'did', "didn't", 'do', 'does', "doesn't", 'doing', "don't", 'down', 'during', 'each', 'few', 'for',
                'from', 'further', 'get', 'got', 'had', "hadn't", 'has', "hasn't", 'have', "haven't", 'having', 'he', "he'd",
                "he'll", "he's", 'her', 'here', "here's", 'hers', 'herself', 'him', 'himself', 'his', 'how', "how's", 'i', "i'd",
                "i'll", "i'm", "i've", 'if', 'in', 'into', 'is', "isn't", 'it', "it's", 'its', 'itself', 'just', "let's", 'me',
                'might', 'more', 'most', "mustn't", 'my', 'myself', 'no', 'nor', 'not', 'of', 'off', 'on', 'once', 'only', 'or',
                'other', 'ought', 'our', 'ours', 'ourselves', 'out', 'over', 'own', 'same', "shan't", 'she', "she'd", "she'll",
                "she's", 'should', "shouldn't", 'so', 'some', 'such', 'than', 'that', "that's", 'the', 'their', 'theirs', 'them',
                'themselves', 'then', 'there', "there's", 'these', 'they', "they'd", "they'll", "they're", "they've", 'this',
                'those', 'through', 'to', 'too', 'under', 'until', 'up', 'very', 'was', "wasn't", 'we', "we'd", "we'll", "we're",
                "we've", 'were', "weren't", 'what', "what's", 'when', "when's", 'where', "where's", 'which', 'while', 'who',
                "who's", 'whom', 'why', "why's", 'will', 'with', "won't", 'would', "wouldn't", 'you', "you'd", "you'll",
                "you're", "you've", 'your', 'yours', 'yourself', 'yourselves',
                'also', 'new', 'said', 'says', 'one', 'two', 'like', 'will', 'can', 'may', 'use', 'used', 'using',
                'news', 'report', 'reports', 'article', 'according', 'first', 'last', 'next', 'still', 'well',
                'however', 'another', 'since', 'around', 'back', 'even', 'much', 'many', 'made', 'make', 'take', 'every'
            ]);

            /**
             * Tokenize text: lowercase, remove punctuation, split into words, filter stop words.
             * Returns array of meaningful tokens.
             */
            function tokenize(text) {
                if (!text) return [];
                return text
                    .toLowerCase()
                    .replace(/[^a-z0-9\s]/g, ' ')
                    .split(/\s+/)
                    .filter(w => w.length > 2 && !STOP_WORDS.has(w));
            }

            /**
             * Extract named entities from ORIGINAL (pre-lowercase) text.
             * Detects: capitalized multi-word names, standalone capitalized words, numbers/amounts.
             * Returns a Set of lowercase entity strings.
             */
            function extractEntities(text) {
                if (!text) return new Set();
                const entities = new Set();

                // Multi-word capitalized names: "Shandong Energy", "Goldman Sachs", "New York"
                const multiWordPattern = /\b([A-Z][a-z]+(?:\s+[A-Z][a-z]+)+)\b/g;
                let match;
                while ((match = multiWordPattern.exec(text)) !== null) {
                    const entity = match[1].toLowerCase();
                    if (!STOP_WORDS.has(entity)) entities.add(entity);
                }

                // Single capitalized words (likely proper nouns), min 3 chars
                const singleCapPattern = /\b([A-Z][a-z]{2,})\b/g;
                while ((match = singleCapPattern.exec(text)) !== null) {
                    const w = match[1].toLowerCase();
                    if (!STOP_WORDS.has(w) && w.length > 3) entities.add(w);
                }

                // ALL-CAPS acronyms: "CEO", "IPO", "AI", "ESG"
                const acronymPattern = /\b([A-Z]{2,6})\b/g;
                while ((match = acronymPattern.exec(text)) !== null) {
                    entities.add(match[1].toLowerCase());
                }

                // Dollar/number amounts: "$5B", "500 million", "2024"
                const amountPattern = /\$[\d.,]+\s*(?:billion|million|trillion|[BMTKk])?|\b\d{4}\b|\b\d+\s*(?:billion|million|trillion)\b/gi;
                while ((match = amountPattern.exec(text)) !== null) {
                    entities.add(match[0].toLowerCase().trim());
                }

                return entities;
            }

            /**
             * Generate bigrams from token array.
             * "nvidia quarterly earnings report" => ["nvidia_quarterly", "quarterly_earnings", "earnings_report"]
             */
            function generateBigrams(tokens) {
                const bigrams = [];
                for (let i = 0; i < tokens.length - 1; i++) {
                    bigrams.push(tokens[i] + '_' + tokens[i + 1]);
                }
                return bigrams;
            }

            /**
             * Jaccard similarity between two Sets.
             * |intersection| / |union|
             */
            function jaccardSimilarity(setA, setB) {
                if (setA.size === 0 && setB.size === 0) return 0;
                let intersection = 0;
                setA.forEach(item => { if (setB.has(item)) intersection++; });
                const union = setA.size + setB.size - intersection;
                return union === 0 ? 0 : intersection / union;
            }

            /**
             * Extract a contextual summary from a news item.
             * Uses unigrams + bigrams from title (3x weight) and description,
             * plus extracted named entities (company names, proper nouns, acronyms).
             */
            function extractContextualSummary(item) {
                const rawTitle = item.title || '';
                const rawSummary = item.summary || '';

                // Unigrams
                const titleTokens = tokenize(rawTitle);
                const summaryTokens = tokenize(rawSummary);

                // Bigrams for phrase-level matching
                const titleBigrams = generateBigrams(titleTokens);
                const summaryBigrams = generateBigrams(summaryTokens);

                // Named entities from original casing
                const entities = extractEntities(rawTitle + ' ' + rawSummary);

                // Build combined token list: title weighted 3x, bigrams 2x, entities 3x
                const allTokens = [
                    ...titleTokens, ...titleTokens, ...titleTokens,  // title 3x
                    ...summaryTokens,
                    ...titleBigrams, ...titleBigrams,                 // bigrams 2x
                    ...summaryBigrams,
                    ...Array.from(entities), ...Array.from(entities), ...Array.from(entities) // entities 3x
                ];

                // Build term frequency map
                const tf = {};
                allTokens.forEach(t => { tf[t] = (tf[t] || 0) + 1; });

                // Sort by frequency, take top 20 key terms as the contextual summary
                const sorted = Object.entries(tf).sort((a, b) => b[1] - a[1]);
                const topTerms = sorted.slice(0, 20).map(([term]) => term);

                return {
                    terms: topTerms,
                    fingerprint: topTerms.join(' '),
                    termFreq: tf,
                    entities: entities  // Keep entities for hybrid matching
                };
            }

            /**
             * Build TF-IDF vectors for a collection of items.
             * Returns items enriched with .contextSummary and .tfidfVector
             */
            function buildTfidfVectors(items) {
                const enriched = items.map(item => ({
                    ...item,
                    contextSummary: extractContextualSummary(item)
                }));

                const N = enriched.length;
                if (N === 0) return enriched;

                // Compute document frequency
                const df = {};
                enriched.forEach(item => {
                    const uniqueTerms = new Set(Object.keys(item.contextSummary.termFreq));
                    uniqueTerms.forEach(term => { df[term] = (df[term] || 0) + 1; });
                });

                // Compute TF-IDF vector for each item
                enriched.forEach(item => {
                    const vector = {};
                    const tf = item.contextSummary.termFreq;
                    const maxTf = Math.max(...Object.values(tf), 1);

                    for (const [term, freq] of Object.entries(tf)) {
                        const normalizedTf = 0.5 + 0.5 * (freq / maxTf);
                        const idf = Math.log((N + 1) / (1 + (df[term] || 0)));
                        vector[term] = normalizedTf * idf;
                    }
                    item.tfidfVector = vector;
                });

                return enriched;
            }

            /**
             * Cosine similarity between two TF-IDF vectors.
             */
            function cosineSimilarity(vecA, vecB) {
                const allTerms = new Set([...Object.keys(vecA), ...Object.keys(vecB)]);
                let dotProduct = 0, magA = 0, magB = 0;

                allTerms.forEach(term => {
                    const a = vecA[term] || 0;
                    const b = vecB[term] || 0;
                    dotProduct += a * b;
                    magA += a * a;
                    magB += b * b;
                });

                const magnitude = Math.sqrt(magA) * Math.sqrt(magB);
                return magnitude === 0 ? 0 : dotProduct / magnitude;
            }

            /**
             * Hybrid similarity: combines TF-IDF cosine with Jaccard on entities.
             * Takes the MAX of the two, then applies entity-overlap boost.
             * This catches same-story articles even when worded differently.
             */
            function hybridSimilarity(itemA, itemB) {
                // 1. TF-IDF cosine similarity (captures term-level overlap)
                const cosSim = cosineSimilarity(itemA.tfidfVector, itemB.tfidfVector);

                // 2. Jaccard on named entities (captures who/what overlap)
                const entitySim = jaccardSimilarity(itemA.contextSummary.entities, itemB.contextSummary.entities);

                // 3. Jaccard on top key terms (captures topic overlap)
                const termsA = new Set(itemA.contextSummary.terms);
                const termsB = new Set(itemB.contextSummary.terms);
                const termsSim = jaccardSimilarity(termsA, termsB);

                // Take the best signal
                let score = Math.max(cosSim, entitySim, termsSim);

                // 4. Entity overlap boost: if >=2 named entities match, boost by +0.15
                let sharedEntities = 0;
                itemA.contextSummary.entities.forEach(e => {
                    if (itemB.contextSummary.entities.has(e)) sharedEntities++;
                });
                if (sharedEntities >= 2) {
                    score = Math.min(1.0, score + 0.15);
                }

                return score;
            }

            /**
             * Contextual deduplication with hybrid scoring.
             * Groups items where hybrid similarity >= 5%.
             * Keeps the most recent item from each group.
             */
            function contextualDedupe(items, threshold = 0.05) {
                const enriched = buildTfidfVectors(items);
                const used = new Array(enriched.length).fill(false);
                const result = [];

                // Sort by date descending so we prefer keeping the most recent
                const indexed = enriched.map((item, i) => ({ item, idx: i }));
                indexed.sort((a, b) => b.item.date - a.item.date);

                for (const { item: candidate, idx: cIdx } of indexed) {
                    if (used[cIdx]) continue;
                    used[cIdx] = true;

                    // Find all items similar to this candidate
                    const duplicates = [];
                    for (const { item: other, idx: oIdx } of indexed) {
                        if (used[oIdx] || oIdx === cIdx) continue;
                        const sim = hybridSimilarity(candidate, other);
                        if (sim >= threshold) {
                            used[oIdx] = true;
                            duplicates.push({ ...other, similarity: Math.round(sim * 100) });
                        }
                    }

                    // Attach duplicate count and contextual summary to the kept item
                    result.push({
                        ...candidate,
                        contextFingerprint: candidate.contextSummary.fingerprint,
                        duplicateCount: duplicates.length,
                        duplicateTitles: duplicates.slice(0, 3).map(d => `${d.title} (${d.similarity}% match)`)
                    });
                }

                return result;
            }

            // Legacy Levenshtein for the old fuzzy mode
            function levenshtein(a, b) {
                if (a.length === 0) return b.length;
                if (b.length === 0) return a.length;
                const matrix = [];
                for (let i = 0; i <= b.length; i++) matrix[i] = [i];
                for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
                for (let i = 1; i <= b.length; i++) {
                    for (let j = 1; j <= a.length; j++) {
                        if (b.charAt(i - 1) === a.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1)
                            );
                        }
                    }
                }
                return matrix[b.length][a.length];
            }

            function isSimilar(s1, s2, threshold = 0.6) {
                if (!s1 || !s2) return false;
                const longer = s1.length > s2.length ? s1 : s2;
                if (longer.length === 0) return true;
                const dist = levenshtein(s1.toLowerCase(), s2.toLowerCase());
                return (longer.length - dist) / longer.length >= threshold;
            }

            // --- APP ---

            // --- CLASSIFICATION LOGIC ---
            const CATEGORIES = {
                "Electricity": ["grid", "power", "electricity", "utility", "transmission", "substation", "renewable", "solar", "wind", "energy", "voltage"],
                "Oil & Gas": ["oil", "gas", "pipeline", "crude", "petroleum", "lng", "refinery", "drilling", "shale", "offshore"],
                "Data Center": ["data center", "hyperscale", "cloud", "server", "data centre", "capacit"],
                "Software/AI": ["software", "app", "platform", "saas", "ai", "artificial intelligence", "llm", "chatbot", "genai", "cyber"],
                "Finance/Biz": ["stock", "share", "market", "revenue", "profit", "quarter", "earnings", "deal", "acquisition", "merger"]
            };

            const classifyNews = (text) => {
                const lower = text.toLowerCase();
                for (const [cat, keywords] of Object.entries(CATEGORIES)) {
                    if (keywords.some(k => lower.includes(k))) return cat;
                }
                return "General";
            };

            function App() {
                const [status, setStatus] = useState("idle");
                const [targetCompanies, setTargetCompanies] = useState("");
                const [startDate, setStartDate] = useState("");
                const [endDate, setEndDate] = useState("");
                const [rawNewsItems, setRawNewsItems] = useState([]); // Store all fetched items
                const [filteredNewsItems, setFilteredNewsItems] = useState([]); // Items after dedupe & display filters
                const [progress, setProgress] = useState("");
                const [auditLog, setAuditLog] = useState([]); // Track success/failure per chunk

                // Options
                const [dedupeMode, setDedupeMode] = useState("contextual"); // 'strict', 'contextual', or 'fuzzy'
                const [filterCategory, setFilterCategory] = useState("All");
                const [filterSource, setFilterSource] = useState("All");

                // Activity Log Ref
                const logRef = React.useRef(null);
                const addLog = (msg) => {
                    if (logRef.current) {
                        logRef.current.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
                        logRef.current.scrollTop = logRef.current.scrollHeight;
                    }
                };

                useEffect(() => {
                    applyFiltersAndDedupe();
                }, [rawNewsItems, dedupeMode, filterCategory, filterSource]);

                const applyFiltersAndDedupe = () => {
                    if (rawNewsItems.length === 0) {
                        setFilteredNewsItems([]);
                        return;
                    }

                    // 1. Deduplication
                    let unique = [];
                    if (dedupeMode === 'strict') {
                        // Link must be unique
                        const seen = new Set();
                        rawNewsItems.forEach(item => {
                            if (!seen.has(item.link)) {
                                seen.add(item.link);
                                unique.push({ ...item, duplicateCount: 0, duplicateTitles: [], contextFingerprint: '' });
                            }
                        });
                    } else if (dedupeMode === 'contextual') {
                        // Contextual Summary Deduplication (50% TF-IDF cosine similarity)
                        unique = contextualDedupe(rawNewsItems, 0.05);
                        const removedCount = rawNewsItems.length - unique.length;
                        if (removedCount > 0) {
                            addLog(`Contextual dedup removed ${removedCount} duplicate(s) from ${rawNewsItems.length} items.`);
                        }
                    } else {
                        // Legacy Fuzzy Match (Title > 60% OR Summary > 50%)
                        rawNewsItems.forEach(item => {
                            const isTitleDuplicate = unique.some(u => isSimilar(u.title, item.title, 0.6));
                            const isSummaryDuplicate = unique.some(u => isSimilar(u.summary, item.summary, 0.5));

                            if (!isTitleDuplicate && !isSummaryDuplicate) {
                                unique.push({ ...item, duplicateCount: 0, duplicateTitles: [], contextFingerprint: '' });
                            }
                        });
                    }

                    // 2. Sorting
                    unique.sort((a, b) => b.date - a.date);

                    // 3. UI Filters
                    let result = unique;
                    if (filterCategory !== "All") {
                        result = result.filter(i => i.category === filterCategory);
                    }
                    if (filterSource !== "All") {
                        result = result.filter(i => i.source === filterSource);
                    }

                    setFilteredNewsItems(result);
                };

                const fetchNews = async () => {
                    if (!targetCompanies) { alert("Please enter companies."); return; }

                    setStatus("processing");
                    setRawNewsItems([]);
                    setAuditLog([]); // Reset audit log
                    if (logRef.current) logRef.current.innerHTML = "";
                    addLog("Starting search...");

                    const companies = targetCompanies.split(',').map(c => c.trim()).filter(c => c);
                    if (companies.length === 0) { alert("Invalid companies."); setStatus("idle"); return; }

                    const start = startDate ? new Date(startDate) : new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                    const end = endDate ? new Date(endDate) : new Date();
                    end.setHours(23, 59, 59);

                    // CHUNK STRATEGY: 7 Days
                    const chunks = [];
                    let current = new Date(start);
                    while (current < end) {
                        let next = new Date(current);
                        next.setDate(next.getDate() + 7);
                        if (next > end) next = new Date(end);
                        chunks.push({
                            s: current.toISOString().split('T')[0],
                            e: next.toISOString().split('T')[0]
                        });
                        current.setDate(current.getDate() + 8);
                    }
                    if (chunks.length === 0) chunks.push({ s: start.toISOString().split('T')[0], e: end.toISOString().split('T')[0] });

                    let fetched = [];
                    let totalSteps = companies.length * chunks.length * 2;
                    let completed = 0;

                    const parser = new DOMParser();

                    const runQuery = async (queryType, queryStr, company, chunkDate) => {
                        // Prioritized Proxy List (Reliable ones first)
                        const PROXIES = [
                            (url) => `https://api.allorigins.win/get?url=${encodeURIComponent(url)}&t=${Date.now()}`,
                            (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
                            (url) => `https://api.cors.lol/?url=${encodeURIComponent(url)}`,
                            (url) => `https://thingproxy.freeboard.io/fetch/${encodeURIComponent(url)}`,
                            (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
                        ];

                        // Partial shuffle: keep top 2 fixed, shuffle the rest for fallback variety
                        for (let i = PROXIES.length - 1; i > 2; i--) {
                            const j = 2 + Math.floor(Math.random() * (i - 1));
                            [PROXIES[i], PROXIES[j]] = [PROXIES[j], PROXIES[i]];
                        }

                        const MAX_RETRIES = PROXIES.length * 2;
                        let attempts = 0;

                        while (attempts < MAX_RETRIES) {
                            const proxyIdx = attempts % PROXIES.length;
                            const proxyFn = PROXIES[proxyIdx];
                            const rssUrl = `https://news.google.com/rss/search?q=${queryStr}&hl=en-US&gl=US&ceid=US:en`;
                            const targetUrl = proxyFn(rssUrl);

                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 15000); // 15s relaxed timeout

                            try {
                                const res = await fetch(targetUrl, { signal: controller.signal });
                                clearTimeout(timeoutId);

                                if (!res.ok) throw new Error(`HTTP ${res.status}`);

                                let xmlContent = "";
                                try {
                                    const text = await res.text();
                                    try {
                                        const data = JSON.parse(text);
                                        if (data.contents) xmlContent = data.contents;
                                        else if (data.body) xmlContent = data.body;
                                        else if (typeof data === 'string') xmlContent = data;
                                        else xmlContent = text;
                                    } catch (jsonErr) {
                                        xmlContent = text;
                                    }
                                } catch (readErr) {
                                    throw new Error(`Read failed: ${readErr.message}`);
                                }

                                if (xmlContent && (xmlContent.includes("<rss") || xmlContent.includes("<feed") || xmlContent.includes("<?xml"))) {
                                    const xmlDoc = parser.parseFromString(xmlContent, "text/xml");
                                    const items = xmlDoc.querySelectorAll("item");

                                    if (items.length > 0) {
                                        addLog(`Found ${items.length} items for ${company} [${queryType}]`);
                                        return Array.from(items);
                                    } else {
                                        addLog(`No items found for ${company} [${queryType}]. Moving to next...`);
                                        return [];
                                    }
                                } else {
                                    throw new Error("Invalid RSS response");
                                }

                            } catch (e) {
                                clearTimeout(timeoutId);
                                attempts++;
                                const errorSnippet = e.message.substring(0, 40);
                                if (attempts >= MAX_RETRIES) {
                                    addLog(`Error: ${company} - Gave up after ${MAX_RETRIES} attempts.`);
                                } else {
                                    const nextDelay = 1500 + Math.random() * 2000;
                                    // Soft log
                                    addLog(`Proxy busy (${errorSnippet}). Switching proxy in ${(nextDelay / 1000).toFixed(1)}s...`);
                                    await new Promise(r => setTimeout(r, nextDelay));
                                }
                            }
                        }
                        return [];
                    };

                    for (let i = 0; i < companies.length; i++) {
                        const company = companies[i];

                        for (let j = 0; j < chunks.length; j++) {
                            const chunk = chunks[j];

                            // 1. General Query
                            completed++;
                            setProgress(`${Math.round((completed / totalSteps) * 100)}% | ${company} (General)`);
                            let qGeneral = encodeURIComponent(`${company} after:${chunk.s} before:${chunk.e}`);
                            const itemsGen = await runQuery("General", qGeneral, company, chunk.s);

                            setAuditLog(prev => [...prev, {
                                Company: company,
                                StartDate: chunk.s,
                                EndDate: chunk.e,
                                Type: "General",
                                Status: itemsGen.length >= 0 ? "Success" : "Failed",
                                ItemsFound: itemsGen.length
                            }]);

                            // 2. Press Release Query
                            completed++;
                            setProgress(`${Math.round((completed / totalSteps) * 100)}% | ${company} (Press Release)`);
                            let qPR = encodeURIComponent(`${company} "press release" after:${chunk.s} before:${chunk.e}`);
                            const itemsPR = await runQuery("Press Release", qPR, company, chunk.s);

                            setAuditLog(prev => [...prev, {
                                Company: company,
                                StartDate: chunk.s,
                                EndDate: chunk.e,
                                Type: "Press Release",
                                Status: itemsPR.length >= 0 ? "Success" : "Failed",
                                ItemsFound: itemsPR.length
                            }]);


                            const allItems = [...itemsGen, ...itemsPR];

                            allItems.forEach(node => {
                                const title = node.querySelector("title")?.textContent || "";
                                const link = node.querySelector("link")?.textContent || "";
                                const pubDateStr = node.querySelector("pubDate")?.textContent || "";
                                const description = node.querySelector("description")?.textContent || "";
                                const sourceNode = node.querySelector("source");

                                // Source Logic: Prefer <source> tag, else parse from title
                                let source = sourceNode?.textContent || "Google News";
                                let cleanTitle = title;

                                const lastDash = cleanTitle.lastIndexOf(" - ");
                                if (lastDash > 0) {
                                    if (source === "Google News") source = cleanTitle.substring(lastDash + 3);
                                    cleanTitle = cleanTitle.substring(0, lastDash);
                                }

                                const div = document.createElement("div");
                                div.innerHTML = description;
                                const summary = div.textContent || div.innerText || "";

                                const category = classifyNews((cleanTitle + " " + summary).toLowerCase());

                                fetched.push({
                                    title: cleanTitle,
                                    link: link,
                                    date: new Date(pubDateStr),
                                    source: source,
                                    company: company,
                                    category: category,
                                    summary: summary
                                });
                            });

                            // Delay
                            await new Promise(r => setTimeout(r, 500));
                        }
                    }

                    addLog(`Search complete. Processing ${fetched.length} raw items...`);
                    setRawNewsItems(fetched);
                    setStatus("done");
                    setProgress("");
                };


                const handleDownload = () => {
                    if (filteredNewsItems.length === 0 && auditLog.length === 0) return;

                    const wb = XLSX.utils.book_new();

                    // Sheet 1: News Items
                    if (filteredNewsItems.length > 0) {
                        const dataForExcel = filteredNewsItems.map(item => ({
                            Date: item.date.toLocaleDateString(),
                            Category: item.category,
                            Company: item.company,
                            Source: item.source,
                            Headline: item.title,
                            Summary: item.summary,
                            Link: item.link
                        }));
                        const ws = XLSX.utils.json_to_sheet(dataForExcel);
                        XLSX.utils.book_append_sheet(wb, ws, "News");
                    }

                    // Sheet 2: Audit Log
                    if (auditLog.length > 0) {
                        const auditWs = XLSX.utils.json_to_sheet(auditLog);
                        XLSX.utils.book_append_sheet(wb, auditWs, "Search Audit");
                    }

                    XLSX.writeFile(wb, "Enhanced_News_Report.xlsx");
                };

                // Derived lists for filters
                const sources = ["All", ...new Set(rawNewsItems.map(i => i.source))].sort();
                const categories = ["All", ...Object.keys(CATEGORIES), "General"];

                return (
                    <div className="max-w-[95%] mx-auto p-6 font-sans text-slate-800">
                        <header className="mb-8 text-center bg-blue-700 text-white p-6 rounded-xl shadow-lg">
                            <h1 className="text-3xl font-extrabold mb-2">Company News Aggregator Pro</h1>
                            <p className="opacity-90">Deep Search, Categorization & Source Intelligence</p>
                        </header>

                        <div className="bg-white p-6 rounded-xl shadow border border-slate-200 mb-8 grid grid-cols-1 lg:grid-cols-4 gap-6">
                            <div className="lg:col-span-1 border-r pr-6 space-y-4">
                                <h3 className="font-bold text-gray-700 border-b pb-2">1. Search Config</h3>
                                <div>
                                    <label className="block text-xs font-bold uppercase text-slate-500 mb-1">Companies</label>
                                    <input type="text" className="w-full p-2 border rounded text-sm" placeholder="e.g. OpenAI, Nvidia" value={targetCompanies} onChange={e => setTargetCompanies(e.target.value)} />
                                </div>
                                <div className="grid grid-cols-2 gap-2">
                                    <div><label className="block text-xs font-bold uppercase text-slate-500 mb-1">Start</label><input type="date" className="w-full p-2 border rounded text-sm" value={startDate} onChange={e => setStartDate(e.target.value)} /></div>
                                    <div><label className="block text-xs font-bold uppercase text-slate-500 mb-1">End</label><input type="date" className="w-full p-2 border rounded text-sm" value={endDate} onChange={e => setEndDate(e.target.value)} /></div>
                                </div>
                                <button onClick={fetchNews} disabled={status === 'processing'} className={`w-full py-2 rounded font-bold text-white text-sm mt-2 ${status === 'processing' ? 'bg-blue-400' : 'bg-blue-600 hover:bg-blue-700'}`}>
                                    {status === 'processing' ? 'Searching...' : 'Search Web'}
                                </button>
                                {progress && <div className="text-xs text-blue-600 animate-pulse text-center mt-2">{progress}</div>}

                                <div className="mt-4 border-t pt-2">
                                    <h4 className="text-xs font-bold text-slate-500 uppercase mb-1">Activity Log</h4>
                                    <div ref={logRef} className="h-32 overflow-y-auto bg-slate-900 text-green-400 font-mono text-xs p-2 rounded">
                                        <div className="opacity-50">Ready to search...</div>
                                    </div>
                                </div>
                            </div>

                            <div className="lg:col-span-3">
                                <div className="flex justify-between items-center border-b pb-2 mb-4">
                                    <h3 className="font-bold text-gray-700">2. Results & Filters ({filteredNewsItems.length} items)</h3>
                                    <div className="flex items-center gap-2">
                                        <span className="text-xs font-medium text-slate-500">Deduplication:</span>
                                        <select className="border rounded text-sm p-1 bg-slate-50" value={dedupeMode} onChange={e => setDedupeMode(e.target.value)}>
                                            <option value="strict">Strict (URL only)</option>
                                            <option value="contextual">Contextual (5% Summary Match)</option>
                                            <option value="fuzzy">Legacy Fuzzy (Levenshtein)</option>
                                        </select>
                                        <button onClick={handleDownload} disabled={filteredNewsItems.length === 0} className="ml-4 bg-green-600 text-white px-4 py-1 rounded text-sm hover:bg-green-700">Download Excel</button>
                                    </div>
                                </div>

                                {rawNewsItems.length > 0 && (
                                    <div className="flex gap-4 mb-4 bg-slate-50 p-3 rounded">
                                        <div>
                                            <label className="block text-xs font-bold text-slate-500">Filter Category</label>
                                            <select className="border rounded text-sm p-1 w-40" value={filterCategory} onChange={e => setFilterCategory(e.target.value)}>
                                                {categories.map(c => <option key={c} value={c}>{c}</option>)}
                                            </select>
                                        </div>
                                        <div>
                                            <label className="block text-xs font-bold text-slate-500">Filter Source</label>
                                            <select className="border rounded text-sm p-1 w-40" value={filterSource} onChange={e => setFilterSource(e.target.value)}>
                                                {sources.map(s => <option key={s} value={s}>{s}</option>)}
                                            </select>
                                        </div>
                                    </div>
                                )}

                                <div className="overflow-x-auto border rounded max-h-[600px]">
                                    <table className="w-full text-left text-sm">
                                        <thead className="bg-slate-100 sticky top-0 z-10 shadow-sm text-slate-600">
                                            <tr>
                                                <th className="p-3 w-28">Date</th>
                                                <th className="p-3 w-28">Category</th>
                                                <th className="p-3 w-32">Company</th>
                                                <th className="p-3 w-32">Source</th>
                                                <th className="p-3">Headline & Summary</th>
                                            </tr>
                                        </thead>
                                        <tbody className="divide-y divide-slate-100">
                                            {filteredNewsItems.map((item, idx) => (
                                                <tr key={idx} className="hover:bg-slate-50">
                                                    <td className="p-3 text-slate-500 whitespace-nowrap">{item.date.toLocaleDateString()}</td>
                                                    <td className="p-3">
                                                        <span className={`px-2 py-1 rounded text-xs font-medium 
                                                                ${item.category === 'Electricity' ? 'bg-yellow-100 text-yellow-800' :
                                                                item.category === 'Oil & Gas' ? 'bg-orange-100 text-orange-800' :
                                                                    item.category === 'Data Center' ? 'bg-purple-100 text-purple-800' :
                                                                        'bg-gray-100 text-gray-800'}`}>
                                                            {item.category}
                                                        </span>
                                                    </td>
                                                    <td className="p-3 font-medium">{item.company}</td>
                                                    <td className="p-3 text-slate-600 truncate max-w-[150px]" title={item.source}>{item.source}</td>
                                                    <td className="p-3">
                                                        <a href={item.link} target="_blank" className="text-blue-600 hover:underline font-bold block mb-1">
                                                            {item.title}
                                                        </a>
                                                        <div className="text-xs text-slate-500 line-clamp-2" title={item.summary}>
                                                            {item.summary}
                                                        </div>
                                                        {dedupeMode === 'contextual' && item.contextFingerprint && (
                                                            <div className="mt-1 flex flex-wrap gap-1">
                                                                {item.contextFingerprint.split(' ').slice(0, 8).map((term, ti) => (
                                                                    <span key={ti} className="px-1.5 py-0.5 bg-indigo-50 text-indigo-600 text-[10px] rounded font-mono">{term}</span>
                                                                ))}
                                                            </div>
                                                        )}
                                                        {item.duplicateCount > 0 && (
                                                            <div className="mt-1 text-[11px] text-amber-600 bg-amber-50 px-2 py-1 rounded" title={item.duplicateTitles?.join('\n')}>
                                                                âš¡ {item.duplicateCount} similar article{item.duplicateCount > 1 ? 's' : ''} merged
                                                            </div>
                                                        )}
                                                    </td>
                                                </tr>
                                            ))}
                                        </tbody>
                                    </table>
                                    {filteredNewsItems.length === 0 && <div className="p-8 text-center text-slate-400">No news found matching your filters.</div>}
                                </div>
                            </div>
                        </div>
                    </div>
                );
            }

            const root = ReactDOM.createRoot(document.getElementById('root'));
            root.render(<App />);

        } catch (err) {
            console.error(err);
            document.getElementById('debug-error').style.display = 'block';
            document.getElementById('debug-content').textContent += `App Error: ${err.message}\n${err.stack}`;
        }
    </script>
</body>


</html>
